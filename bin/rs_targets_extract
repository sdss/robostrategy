#!/usr/bin/env python
# encoding: utf-8
#
# @Author: Michael R. Blanton
# @Date: Aug 3, 2018
# @Filename: rs_targets_extract
# @License: BSD 3-Clause
# @Copyright: Michael R. Blanton


from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals

import configparser
import argparse
import os
import sys
import numpy as np
import fitsio
import peewee
import roboscheduler.cadence as cadence
import robostrategy.params as params
import sdssdb.peewee.sdss5db.targetdb as targetdb
import sdss_access.path

from sdssdb.peewee.sdss5db import database
database.set_profile('operations')

sdss_path = sdss_access.path.Path(release='sdss5', preserve_envvars=True)

target_dtype = [('rsid', np.int64), # set equal to carton_to_target_pk
                ('carton_to_target_pk', np.int64), # from carton_to_target
                ('priority', np.int32),
                ('value', np.float32),
                ('lambda_eff', np.float32),
                ('delta_ra', np.float64),
                ('delta_dec', np.float64),
                ('ra', np.float64),  # from target
                ('dec', np.float64),
                ('epoch', np.float32),
                ('pmra', np.float32),
                ('pmdec', np.float32),
                ('parallax', np.float32),
                ('catalogid', np.int64),
                ('target_pk', np.int64),
                ('carton', np.unicode_, 30), # from carton
                ('program', np.unicode_, 15), 
                ('mapper', np.unicode_, 5), # from mapper
                ('category', np.unicode_, 15), # from category
                ('cadence', np.unicode_, 30), # from cadence
                ('fiberType', np.unicode_, 10),  # from instrument
                ('plan', np.unicode_, 10),  # from version
                ('tag', np.unicode_, 10)]


def get_targets(cfg=None):

    targets = np.zeros(0, dtype=target_dtype)

    for carton in cfg['Cartons']:
        version = cfg['Cartons'][carton]
        print("Extracting carton {p}, version {v}".format(p=carton,
                                                          v=version))

        # First look at all targets in this carton/version
        ntall = (targetdb.Target.select(targetdb.Target.pk)
                 .join(targetdb.CartonToTarget)
                 .join(targetdb.Carton)
                 .join(targetdb.Version)
                 .where((targetdb.Carton.carton == carton) &
                        (targetdb.Version.plan == version))).count()

        # Now look at those with a cadence and instrument not null
        nt = (targetdb.Target.select(targetdb.Target.pk)
              .join(targetdb.CartonToTarget)
              .join(targetdb.Instrument, peewee.JOIN.LEFT_OUTER).switch(targetdb.CartonToTarget)
              .join(targetdb.Cadence, peewee.JOIN.LEFT_OUTER).switch(targetdb.CartonToTarget)
              .join(targetdb.Carton)
              .join(targetdb.Version)
              .where((targetdb.Carton.carton == carton) &
                     (targetdb.Version.plan == version))).count()

        if(nt != ntall):
            print("WARNING: only {nt} of {ntall} targets in carton {carton} have cadence and instrument non-null".format(nt=nt, ntall=ntall, carton=carton))

        print(" ... {nt} targets".format(nt=nt), flush=True)
        if(nt > 0):
            tmp_targets = np.zeros(nt, dtype=target_dtype)

            ts = (targetdb.Target.select(targetdb.Target.ra,
                                         targetdb.Target.dec,
                                         targetdb.Target.pmra,
                                         targetdb.Target.pmdec,
                                         targetdb.Target.epoch,
                                         targetdb.Target.parallax,
                                         targetdb.Target.pk.alias('target_pk'),
                                         targetdb.Target.catalogid,
                                         targetdb.CartonToTarget.pk.alias('carton_to_target_pk'),
                                         targetdb.CartonToTarget.priority,
                                         targetdb.CartonToTarget.value,
                                         targetdb.CartonToTarget.lambda_eff,
                                         targetdb.CartonToTarget.delta_ra,
                                         targetdb.CartonToTarget.delta_dec,
                                         targetdb.Carton.carton,
                                         targetdb.Carton.program,
                                         targetdb.Mapper.label.alias('mapper'),
                                         targetdb.Category.label.alias('category'),
                                         targetdb.Cadence.label.alias('cadence'),
                                         targetdb.Instrument.label.alias('fiberType'),
                                         targetdb.Version.plan,
                                         targetdb.Version.tag)
                  .join(targetdb.CartonToTarget)
                  .join(targetdb.Instrument).switch(targetdb.CartonToTarget)
                  .join(targetdb.Cadence).switch(targetdb.CartonToTarget)
                  .join(targetdb.Carton)
                  .join(targetdb.Mapper).switch(targetdb.Carton)
                  .join(targetdb.Version).switch(targetdb.Carton)
                  .join(targetdb.Category).switch(targetdb.Target)
                  .where((targetdb.Carton.carton == carton) &
                         (targetdb.Version.plan == version))).dicts()

            castn = dict()
            for n in tmp_targets.dtype.names:
                castn[n] = np.cast[type(tmp_targets[n][0])]
            
            problems = []
            for indx, t in enumerate(ts):
                for n in tmp_targets.dtype.names:
                    if(n != 'rsid'):
                        if(t[n] is not None):
                            tmp_targets[n][indx] = castn[n](t[n])
                        else:
                            if(n not in problems):
                                print("problem with {n}".format(n=n))
                                problems.append(n)

            tmp_targets['rsid'] = tmp_targets['carton_to_target_pk']
            targets = np.append(targets, tmp_targets)

    targets['rsid'] = np.arange(len(targets), dtype=np.int64)
    return(targets)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description='Export targets as a FITS file')

    parser.add_argument('-p', '--plan', dest='plan',
                        type=str, help='name of plan', required=True)
    parser.add_argument('-o', '--observatory', dest='observatory',
                        type=str, help='apo or lco',
                        choices=['apo', 'lco'], required=True)

    args = parser.parse_args()
    plan = args.plan
    observatory = args.observatory

    cadencelist = cadence.CadenceList()
    cadences_file = sdss_path.full('rsCadences', plan=plan,
                                   observatory=observatory)
    cadencelist.fromfits(filename=cadences_file, unpickle=True)

    fiberType = dict()
    for c in cadencelist.cadences:
        instrument = cadencelist.cadences[c].instrument
        if(instrument == cadence.Instrument.ApogeeInstrument):
            fiberType[c] = 'APOGEE'
        if(instrument == cadence.Instrument.BossInstrument):
            fiberType[c] = 'BOSS'

    c2cfile = os.path.join(os.getenv('ROBOSTRATEGY_DIR'), 'etc',
                           'cadence-list.cfg')
    c2c = configparser.ConfigParser(allow_no_value=True)
    c2c.optionxform = str
    c2c.read(c2cfile)

    rsParams = params.RobostrategyParams(plan=plan)

    cfgfile = os.path.join(os.getenv('ROBOSTRATEGY_DIR'), 'etc',
                           'robostrategy-{plan}.cfg'.format(plan=plan))
    cfg = configparser.ConfigParser(allow_no_value=True)
    cfg.optionxform = str
    cfg.read(cfgfile)

    targets = get_targets(cfg=cfg)
    print(len(targets))

    print(np.unique(targets['carton']))

    targets_file = sdss_path.full('rsTargets', plan=plan,
                                  observatory=observatory)
    fitsio.write(targets_file, targets, clobber=True)
