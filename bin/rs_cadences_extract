#!/usr/bin/env python
# encoding: utf-8
#
# @Author: Michael R. Blanton
# @Date: Aug 3, 2018
# @Filename: rs_cadences_extract
# @License: BSD 3-Clause
# @Copyright: Michael R. Blanton


from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals

import argparse
import configparser
import os
import sys
import numpy as np
import fitsio
import roboscheduler.cadence as cadence
import robostrategy.params as params
import sdss_access.path
import pickle

from sdssdb.peewee.sdss5db import database
database.set_profile('operations')

sdss_path = sdss_access.path.Path(release='sdss5', preserve_envvars=True)


def copy_cadence(from_cadence, to_cadence, nepochs=None):
    if(nepochs is None):
        nepochs = cadencelist.cadences[from_cadence].nepochs

    cadencelist.add_cadence(name=to_cadence,
                            nepochs=nepochs,
                            instrument=cadencelist.cadences[from_cadence].instrument,
                            skybrightness=cadencelist.cadences[from_cadence].skybrightness[0:nepochs],
                            delta=cadencelist.cadences[from_cadence].delta[0:nepochs],
                            delta_min=cadencelist.cadences[from_cadence].delta_min[0:nepochs],
                            delta_max=cadencelist.cadences[from_cadence].delta_max[0:nepochs],
                            nexp=cadencelist.cadences[from_cadence].nexp[0:nepochs],
                            max_length=cadencelist.cadences[from_cadence].max_length[0:nepochs])
    return


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description='Retrieve cadences from targetdb')

    parser.add_argument('-n', '--ncadence', dest='ncadence',
                        type=np.int32, help='max number of cadences',
                        default=100)
    parser.add_argument('-p', '--plan', dest='plan',
                        type=str, help='name of plan', required=True)
    parser.add_argument('-o', '--observatory', dest='observatory',
                        type=str, help='apo or lco',
                        choices=['apo', 'lco'], required=True)

    args = parser.parse_args()
    plan = args.plan
    observatory = args.observatory

    rsParams = params.RobostrategyParams(plan=plan)

    cadencelist = cadence.CadenceList()
    cadencelist.reset()
    cadencelist.fromdb()

    cadence_change = dict()
    for c in rsParams.cfg['Cadences']:
        adjustment = rsParams.cfg.get('Cadences', c)
        if(adjustment == 'NoDelta'):
            if(c in cadencelist.cadences):
                for i in cadencelist.cadences[c].epoch_indx[:-1]:
                    cadencelist.cadences[c].delta[i] = -1.
                    cadencelist.cadences[c].delta_min[i] = -1.
                    cadencelist.cadences[c].delta_max[i] = -1.
        else:
            if(c in cadencelist.cadences):
                tmpc = cadencelist.cadences[adjustment]
                cadencelist.add_cadence(name=c,
                                        nexposures=tmpc.nexposures,
                                        skybrightness=tmpc.skybrightness,
                                        delta=tmpc.delta,
                                        delta_min=tmpc.delta_min,
                                        delta_max=tmpc.delta_max,
                                        instrument=tmpc.instrument,
                                        max_length=tmpc.max_length)

    copy_cadence('mixed2_single_99x1', 'mixed2_single_nx1')
    copy_cadence('bright_single_99x1', 'bright_single_nx1')
    copy_cadence('bright_1x1', 'bright_single_1x1')
    copy_cadence('bright_2x1', 'bright_single_2x1')
    copy_cadence('mixed2_single_3x1', 'mixed2_single_2x1', nepochs=2)

#
#    hackfile = os.path.join(os.getenv('ROBOSTRATEGY_DIR'),
#                            'data', 'v0.5-cadence-hack.fits')
#    cadencelist.fromfits(hackfile)

#    hackfile = os.path.join(os.getenv('ROBOSTRATEGY_DIR'),
#                            'data', 'v0.5-field-cadences-hack.cfg')
#    cadencelist.fromcfg(hackfile)

#    for c in cadencelist.cadences:
#        if(c[0:6] == 'mixed2'):
#            cadencelist.cadences[c].delta[0:2] = cadencelist.cadences['dark_2x1'].delta
#            cadencelist.cadences[c].delta_min[0:2] = cadencelist.cadences['dark_2x1'].delta_min
#            cadencelist.cadences[c].delta_max[0:2] = cadencelist.cadences['dark_2x1'].delta_max
#            cadencelist.cadences[c].max_length[0:2] = cadencelist.cadences['dark_2x1'].max_length

    if('ExtraFile' in rsParams.cfg['Cadences']):
        print("Extra cadence files:")
        extrafiles = rsParams.cfg.get('Cadences', 'ExtraFile').split()
        for extrafile in extrafiles:
            print(" " + extrafile)
            cadencelist.fromcfg(os.path.join(os.getenv('ROBOSTRATEGY_DIR'),
                                             'data', extrafile))

    cadences_file = sdss_path.full('rsCadences', plan=plan,
                                   observatory=observatory)
    cadences_array = cadencelist.toarray()
    fitsio.write(cadences_file, cadences_array, clobber=True)

    # For cadences with many epochs, we will not solve explicitly for
    # all of the possibilities in RM fields; instead, we will assume that
    # any epochs will do.
    for cn in cadencelist.cadences:
        if((cadencelist.cadences[cn].nepochs >= 5) & ('single' not in cn)):
            cadencelist.cadences[cn].delta_min = cadencelist.cadences[cn].delta - 0.5
            cadencelist.cadences[cn].delta_max = cadencelist.cadences[cn].delta + 1.
            print("{cn}: special case for consistency with RM fields".format(cn=cn))
            c = cadencelist.cadence_consistency(cn, 'dark_174x8')
            print(c[0])
            c = cadencelist.cadence_consistency(cn, 'dark_100x8')
            print(c[0])
        else:
            if('single' not in cn):
                print("{cn}: treat as normal for consistency with RM fields".format(cn=cn))
                c = cadencelist.cadence_consistency(cn, 'dark_174x8')
                c = cadencelist.cadence_consistency(cn, 'dark_100x8')

    pkl_file = cadences_file + ".pkl"
    fp = open(pkl_file, 'wb')
    pickle.dump(cadencelist._cadence_consistency, fp)
    fp.close()
