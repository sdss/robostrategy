#!/usr/bin/env python
# encoding: utf-8
#
# @Author: Michael R. Blanton
# @Date: Aug 3, 2018
# @Filename: rs_cadences_extract
# @License: BSD 3-Clause
# @Copyright: Michael R. Blanton


from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals

import argparse
import configparser
import os
import sys
import numpy as np
import fitsio
import roboscheduler.cadence as cadence
import sdss_access.path
import pickle

from sdssdb.peewee.sdss5db import database
database.set_profile('operations')

sdss_path = sdss_access.path.Path(release='sdss5', preserve_envvars=True)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description='Retrieve cadences from targetdb')

    parser.add_argument('-n', '--ncadence', dest='ncadence',
                        type=np.int32, help='max number of cadences',
                        default=100)
    parser.add_argument('-p', '--plan', dest='plan',
                        type=str, help='name of plan', required=True)
    parser.add_argument('-o', '--observatory', dest='observatory',
                        type=str, help='apo or lco',
                        choices=['apo', 'lco'], required=True)

    args = parser.parse_args()
    plan = args.plan
    observatory = args.observatory

    cfgfile = os.path.join(os.getenv('ROBOSTRATEGY_DIR'), 'etc',
                           'robostrategy-{plan}.cfg'.format(plan=plan))
    cfg = configparser.ConfigParser(allow_no_value=True)
    cfg.optionxform = str
    cfg.read(cfgfile)

    cadencelist = cadence.CadenceList()
    cadencelist.reset()
    cadencelist.fromdb()

    cadence_change = dict()
    for c in cfg['Cadences']:
        adjustment = cfg.get('Cadences', c)
        if(adjustment == 'NoDelta'):
            if(c in cadencelist.cadences):
                for i in cadencelist.cadences[c].epoch_indx[:-1]:
                    cadencelist.cadences[c].delta[i] = -1.
                    cadencelist.cadences[c].delta_min[i] = -1.
                    cadencelist.cadences[c].delta_max[i] = -1.
        else:
            if(c in cadencelist.cadences):
                tmpc = cadencelist.cadences[adjustment]
                cadencelist.add_cadence(name=c,
                                        nexposures=tmpc.nexposures,
                                        skybrightness=tmpc.skybrightness,
                                        delta=tmpc.delta,
                                        delta_min=tmpc.delta_min,
                                        delta_max=tmpc.delta_max,
                                        instrument=tmpc.instrument,
                                        version=tmpc.version)

    hackfile = os.path.join(os.getenv('ROBOSTRATEGY_DIR'),
                            'data', 'v0.5-cadence-hack.fits')
    cadencelist.fromfits(hackfile)

    hackfile = os.path.join(os.getenv('ROBOSTRATEGY_DIR'),
                            'data', 'v0.5-field-cadences-hack.cfg')
    cadencelist.fromcfg(hackfile)

    cadences_file = sdss_path.full('rsCadences', plan=plan,
                                   observatory=observatory)
    cadences_array = cadencelist.toarray()
    fitsio.write(cadences_file, cadences_array, clobber=True)

    # For cadences with many epochs, we will not solve explicitly for
    # all of the possibilities in RM fields; instead, we will assume that
    # any epochs will do.
    for cn in cadencelist.cadences:
        if((cadencelist.cadences[cn].nepochs >= 5) & ('single' not in cn)):
            cadencelist.cadences[cn].delta_min = cadencelist.cadences[cn].delta - 0.5
            cadencelist.cadences[cn].delta_max = cadencelist.cadences[cn].delta + 1.
            print("{cn}: special case for consistency with RM fields".format(cn=cn))
            c = cadencelist.cadence_consistency(cn, 'dark_174x8')
            print(c[0])
            c = cadencelist.cadence_consistency(cn, 'dark_100x8')
            print(c[0])
        else:
            if('single' not in cn):
                print("{cn}: treat as normal for consistency with RM fields".format(cn=cn))
                c = cadencelist.cadence_consistency(cn, 'dark_174x8')
                c = cadencelist.cadence_consistency(cn, 'dark_100x8')

    pkl_file = cadences_file + ".pkl"
    fp = open(pkl_file, 'wb')
    pickle.dump(cadencelist._cadence_consistency, fp)
    fp.close()
