#!/usr/bin/env python
# encoding: utf-8
#
# @Author: Michael R. Blanton
# @Date: Aug 3, 2018
# @Filename: rs_assign_ggsp
# @License: BSD 3-Clause
# @Copyright: Michael R. Blanton


from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals

import argparse
import os
import sys
import numpy as np
import healpy
import fitsio
import sdss_access.path

sdss_path = sdss_access.path.Path()


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description='Field assignment test for Galactic Genesis')

    parser.add_argument('-n', '--ncadence', dest='ncadence',
                        type=np.int32, help='max number of cadences',
                        default=100)
    parser.add_argument('-p', '--plan', dest='plan',
                        type=str, help='name of plan', required=True)
    parser.add_argument('-o', '--observatory', dest='observatory',
                        type=str, help='apo or lco',
                        choices=['apo', 'lco'], required=True)

    args = parser.parse_args()
    plan = args.plan
    observatory = args.observatory

    #read in the fields file.
    fields_file = sdss_path.full('rsFields', plan=plan,
                                 observatory=observatory)
    fields_array = fitsio.read(fields_file)

    #read in the targets file
    targets_file = sdss_path.full('rsTargets', plan=plan,
                                  observatory=observatory)
    targets_all = fitsio.read(targets_file)

    #define n_side for this healpix tesselation
    # nside effectively defines how to scale different resolutions of the grid.
    # specfically, nside gives the number of divisions along the side of a
    #base-resolution pixel that is needed to reach a desired high-resolution partition.
    nside = 32

    #now divide all the targets into a healpix map; hpix will contain the number of the healpix
    #segment that each target lies within
    hpix = healpy.pixelfunc.ang2pix(nside, targets_all['ra'],
                                    targets_all['dec'], lonlat=True)

    #loop through all the fields in question
    for fields_entry in fields_array:

        #find the field ID
        fieldid = fields_entry['fieldid']
        if((fieldid % 1) == 0):
            print(fieldid)

        #find the healpix number of the field center.
        hpix_field = healpy.pixelfunc.ang2pix(nside, fields_entry['racen'],
                                              fields_entry['deccen'],
                                              lonlat=True)
        
        #get the neighboring healpix IDs and add to an array along with the central ID
        neighbors = healpy.pixelfunc.get_all_neighbours(nside, hpix_field)
        hpix_check = np.append(neighbors, np.array([hpix_field]))

        #set up an array to indicate if each healpix pixel is of interest for this field.
        keep = np.zeros(healpy.pixelfunc.nside2npix(nside), dtype=np.int32)

        #flag the healpix containing the field center and its neighbors with a value of 1.
        keep[hpix_check] = 1
        icheck = np.where(keep[hpix])[0]

        #calculate the distance between the field center and each of the targets in the relevant healpix pixels.
        # From Meeus Ch. 17
        deccen_rad = fields_entry['deccen'] * np.pi / 180.
        racen_rad = fields_entry['racen'] * np.pi / 180.
        dec_rad = targets_all['dec'][icheck] * np.pi / 180.
        ra_rad = targets_all['ra'][icheck] * np.pi / 180.
        x = (np.cos(deccen_rad) * np.sin(dec_rad) -
             np.sin(deccen_rad) * np.cos(dec_rad) *
             np.cos(ra_rad - racen_rad))
        y = np.cos(dec_rad) * np.sin(ra_rad - racen_rad)
        z = (np.sin(deccen_rad) * np.sin(dec_rad) +
             np.cos(deccen_rad) * np.cos(dec_rad) *
             np.cos(ra_rad - racen_rad))
        d_rad = np.arctan2(np.sqrt(x**2 + y**2), z)
        d_deg = d_rad * 180. / np.pi

        #identify sources that are within 1.5 degrees of the field center.
        indx = np.where(d_deg < 1.5)[0]
        targets = targets_all[icheck[indx]]

        #write out the targets within this field
        field_target_file = sdss_path.full('rsFieldTargets', plan=plan,
                                           observatory=observatory,
                                           fieldid=fieldid)
        fitsio.write(field_target_file, targets, clobber=True)
