#!/usr/bin/env python
# encoding: utf-8
#
# @Author: Michael R. Blanton
# @Date: Sept 26, 2018
# @Filename: rs_assign_final
# @License: BSD 3-Clause
# @Copyright: Michael R. Blanton


from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals

import argparse
import os
import sys
import multiprocessing
import numpy as np
import roboscheduler.cadence as cadence
import robostrategy.field as field
import robostrategy.allocate
import robostrategy.params as params
import sdss_access.path
import pdb
import fitsio
import time

user_robo_data_dir = os.getenv('ROBOSTRATEGY_DATA')
sdss_path = sdss_access.path.Path(release='sdss5')
os.environ['ROBOSTRATEGY_DATA'] = user_robo_data_dir # Above call overwrites user specified directory

coordinated_dict = None

def assign_field(indx):
    print(time.ctime(time.time()))
    if coordinated_dict is None:
        print('No coordination!')

    fieldid = allocate.field_array['fieldid'][indx]
    if((fieldid % 1) == 0):
        print(fieldid, flush=True)

    f = field.Field(racen=allocate.field_array['racen'][indx],
                    deccen=allocate.field_array['deccen'][indx],
                    observatory=observatory)
    if(rotate):
        f.pa = np.float32(allocate.fields[paname][indx])
        print(f.pa)

    field_target_file = sdss_path.full('rsFieldTargets',
                                       plan=plan, observatory=observatory,
                                       fieldid=fieldid)
    f.targets_fromfits(field_target_file)

    field_cadence = allocate.field_array['cadence'][indx].strip()
    f.set_field_cadence(field_cadence)

    if(f.field_cadence != 'none'):
        f.assign(kaiju=kaiju,coordinated_targets=coordinated_dict)

    field_assigned_file = sdss_path.full('rsFieldAssignments',
                                         plan=plan,
                                         observatory=observatory,
                                         fieldid=fieldid)
    f.tofits(field_assigned_file)


def ra_steps(ra_array, dec, diameter):

       factor =  np.cos(np.deg2rad(dec))
       kp_idx = []
 
       sidx = np.argsort(ra_array)
       assert len(sidx) == len(ra_array)

       for idx, cur_ra in enumerate(ra_array[sidx]):
           if idx == 0:
               kp_idx.append(idx)
               prev_ra = cur_ra.copy()
           else:
               d = (cur_ra - prev_ra)
               if d*factor > diameter:
                   if idx == len(ra_array)- 1:
                       print('Here')
                       if d > 180:
                          d-=360
                          if np.abs(d)*factor < diameter:
                              continue
                   kp_idx.append(idx)
                   prev_ra = cur_ra.copy()
       
#       print(ra_array)
#       print(ra_array[sidx[kp_idx]])
       return sidx[kp_idx]

def find_non_overlapping_fields(racen, deccen, fieldidx, observatory=None):

        if observatory == 'apo':  # copied radii from rs_fields's calls to sloane.Sloane()
            diameter = 1.49 * 2
        elif observatory == 'lco':
            diameter = 0.95 * 2
        else:
            raise ValueError('{} is not a valid observatory'.format(observatory))

        sidx = np.argsort(deccen)
        ra = racen[sidx]
        dec = deccen[sidx]
        fid = fieldidx[sidx]


        non_overlap_ids = []
        cur_idx = 0  # indices to sorted arrays

        while cur_idx < len(sidx):
            non_overlap_ids.append(fid[cur_idx])
            cur_ra = ra[cur_idx]
            cur_dec = dec[cur_idx]
       
     
            # Find next field far enough away in declination to no overlap current field
            deltas = dec - cur_dec
            far_away = np.where(deltas > diameter)[0]
            if len(far_away) == 0:
                cur_idx = 1e6
            else:
                cur_idx = np.min(far_away)

            # Additional "too close in DEC" fields are possible if their RA are far enough
            too_close = np.where( (deltas < diameter) & (deltas > 0))[0]
            ra_diff = (ra[too_close] - cur_ra) * np.cos(np.deg2rad(cur_dec))
            ra_diff[ra_diff > 180] -= 360
            ra_diff[ra_diff < -180] += 360

            if cur_idx < 1e6:  # Need to be non-overlapping with both current and next field
                ra_diff2 = (ra[too_close] - ra[cur_idx]) * np.cos(np.deg2rad(cur_dec))
                ra_diff2[ra_diff2 > 180] -= 360
                ra_diff2[ra_diff2 < -180] += 360
                still_ok = np.where((np.abs(ra_diff) > diameter) & (np.abs(ra_diff2) > diameter))[0]
            else:
                still_ok = np.where(np.abs(ra_diff) > diameter)[0]

            if len(still_ok) > 0:  # Don't forget still_ok are indices of too_close
                 ok_list = ra_steps(ra[too_close[still_ok]], cur_dec, diameter)
                 for x in ok_list:
                     non_overlap_ids.append(fid[too_close[still_ok[x]]])

#                ok_idx = 0 
#                ok_list = [] # This is a list of indexes to still_ok_sort
#         
#                ra_diff_kp = ra_diff[still_ok] 
#                ordered_ok = np.argsort(ra_diff_kp) 
#                ra_diff_kp_sort = ra_diff_kp[ordered_ok] 
#                still_ok_sort = still_ok[ordered_ok] 
#         
#                while ok_idx < len(still_ok_sort): 
#                    ok_list.append(ok_idx) 
#                    cur_ra_diff = ra_diff_kp_sort[ok_idx] 
#                    ok_far_away = np.where(ra_diff_kp_sort - cur_ra_diff > diameter)[0]
#                    if len(ok_far_away) == 0:
#                        ok_idx = 1e6 #to break while loop
#                    else:
#                        ok_idx = np.min(ok_far_away)
#                
#                for x in ok_list:
#                    non_overlap_ids.append(too_close[still_ok_sort[x]])    


        remaining_ids = np.setdiff1d(fieldidx, non_overlap_ids)
        return non_overlap_ids, remaining_ids

def mark_duplicates(done_fieldids, plan=plan, observatory=observatory):

    for fieldid in done_fieldids:
        field_assigned_file = sdss_path.full('rsFieldAssignments',
                                             plan=plan,
                                             observatory=observatory,
                                             fieldid=fieldid)

        allocation = fitsio.read(field_assigned_file, ext=2)
        assigned = np.unique(allocation) # returns all rsids with assignments
        for one in assigned:
            if one in coordinated_dict.keys():
                coordinated_dict[one] = True





if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description='Final assignment based on allocation')

    parser.add_argument('-p', '--plan', dest='plan',
                        type=str, help='name of plan', required=True)
    parser.add_argument('-o', '--observatory', dest='observatory',
                        type=str, help='apo or lco',
                        choices=['apo', 'lco'], required=True)
    parser.add_argument('-n', '--no-kaiju', dest='kaiju',
                        help='do not use kaiju',
                        default=True, action='store_false')
    parser.add_argument('-s', '--start', dest='start',
                        type=np.int32, help='field to start', required=False,
                        default=0)
    parser.add_argument('-e', '--end', dest='end',
                        type=np.int32, help='field to end', required=False,
                        default=-1)
    parser.add_argument('-c','--coordinate',dest='coordinate',
                        default=False, action='store_true',
                        help='coordinate target overlap')

    args = parser.parse_args()
    plan = args.plan
    observatory = args.observatory
    kaiju = args.kaiju
    start = args.start
    end = args.end
    coordinate = args.coordinate
    print(time.ctime(time.time()))

    print("kaiju = {kaiju}".format(kaiju=kaiju))

    rsParams = params.RobostrategyParams(plan=plan)
    if('Rotate' in rsParams.cfg['Fields']):
        rotate = True
        paname = rsParams.cfg['Fields']['Rotate']
    else:
        rotate = False
        paname = ''

    cadencelist = cadence.CadenceList()
    cadences_file = sdss_path.full('rsCadences', plan=plan,
                                   observatory=observatory)
    print(cadences_file)
    cadencelist.fromfits(filename=cadences_file, unpickle=True)

    allocate_file = sdss_path.full('rsAllocation', plan=plan,
                                   observatory=observatory)
    allocate = robostrategy.allocate.AllocateLST(filename=allocate_file,
                                                 observatory=observatory)

    if(end < 0):
        end = allocate.field_array['fieldid'].max()
    ikeep = np.where((allocate.field_array['fieldid'] >= start) &
                     (allocate.field_array['fieldid'] <= end))[0]

    if coordinate:
        #JKC In this attempt, do the following
        # 1 first come up with a set of non-overlapping fields. CREATE SEPARATE FUNCTION   -> DONE
        # 2 Run on multiprocesser. Then build the dictionary and CREATE SEPARATE FUNCTION to mark as done the pre-processed fields
        # Finally, run sequentially the remaining fields as before

        print('Running non-overlapping fields')
        print(time.ctime(time.time()))
        parallel_ids, sequential_ids = find_non_overlapping_fields(allocate.field_array['racen'][ikeep], 
                                                                   allocate.field_array['deccen'][ikeep], 
                                                                   ikeep, observatory=observatory)

        with multiprocessing.Pool() as pool:
            pool.map(assign_field,parallel_ids)

        print("Identifying duplicate targets")
        print(time.ctime(time.time()))
        target_covered_file = sdss_path.full('rsTargets', plan=plan,
                                             observatory=observatory).replace('rsTargets','rsTargetsCovered')
        targets_covered = fitsio.read(target_covered_file)
        in_hex = targets_covered['within_hex']
        duplicated = targets_covered[in_hex > 1]
        coordinated_dict = {x:False for x in duplicated['rsid']}

        print("Updating Duplicate targets observed in fields")
        print(time.ctime(time.time()))
        mark_duplicates(allocate.field_array['fieldid'][parallel_ids], plan=plan, observatory=observatory) # coordinated_dict is global

        print("Running remaining fields sequentially")
        print(time.ctime(time.time()))
        for i in sequential_ids:
            assign_field(i)
    else:
        with multiprocessing.Pool() as pool:
            pool.map(assign_field,ikeep)
    print(time.ctime(time.time()))

