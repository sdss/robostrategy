#!/usr/bin/env python
# encoding: utf-8
#
# @Author: Michael R. Blanton
# @Date: Sept 26, 2018
# @Filename: rs_assign_final
# @License: BSD 3-Clause
# @Copyright: Michael R. Blanton


from __future__ import division
from __future__ import print_function
from __future__ import absolute_import
from __future__ import unicode_literals

import argparse
import os
import sys
import multiprocessing
from itertools import repeat
import numpy as np
import roboscheduler.cadence as cadence
import robostrategy.field as field
import robostrategy.allocate
import robostrategy.params as params
import sdss_access.path
import pdb
import fitsio
import time

user_robo_data_dir = os.getenv('ROBOSTRATEGY_DATA')
sdss_path = sdss_access.path.Path(release='sdss5')
os.environ['ROBOSTRATEGY_DATA'] = user_robo_data_dir # Above call overwrites user specified directory

def assign_field(input):
    dup_dict = input[0]
    indx = input[1]
    print("Extra field id print {}".format(indx))
    fieldid = allocate.field_array['fieldid'][indx]
    if((fieldid % 1) == 0):
        print(fieldid, flush=True)

    f = field.Field(racen=allocate.field_array['racen'][indx],
                    deccen=allocate.field_array['deccen'][indx],
                    observatory=observatory)
    if(rotate):
        f.pa = np.float32(allocate.fields[paname][indx])
        print(f.pa)

    field_target_file = sdss_path.full('rsFieldTargets',
                                       plan=plan, observatory=observatory,
                                       fieldid=fieldid)
    f.targets_fromfits(field_target_file)

    field_cadence = allocate.field_array['cadence'][indx].strip()
    f.set_field_cadence(field_cadence)

    if(f.field_cadence != 'none'):
        f.assign(kaiju=kaiju,coordinated_targets=dup_dict)

    field_assigned_file = sdss_path.full('rsFieldAssignments',
                                         plan=plan,
                                         observatory=observatory,
                                         fieldid=fieldid)
    f.tofits(field_assigned_file)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        prog=os.path.basename(sys.argv[0]),
        description='Final assignment based on allocation')

    parser.add_argument('-p', '--plan', dest='plan',
                        type=str, help='name of plan', required=True)
    parser.add_argument('-o', '--observatory', dest='observatory',
                        type=str, help='apo or lco',
                        choices=['apo', 'lco'], required=True)
    parser.add_argument('-n', '--no-kaiju', dest='kaiju',
                        help='do not use kaiju',
                        default=True, action='store_false')
    parser.add_argument('-s', '--start', dest='start',
                        type=np.int32, help='field to start', required=False,
                        default=0)
    parser.add_argument('-e', '--end', dest='end',
                        type=np.int32, help='field to end', required=False,
                        default=-1)
    parser.add_argument('-c','--coordinate',dest='coordinate',
                        default=False, action='store_true',
                        help='coordinate target overlap')

    args = parser.parse_args()
    plan = args.plan
    observatory = args.observatory
    kaiju = args.kaiju
    start = args.start
    end = args.end
    coordinate = args.coordinate
    print("kaiju = {kaiju}".format(kaiju=kaiju))

    rsParams = params.RobostrategyParams(plan=plan)
    if('Rotate' in rsParams.cfg['Fields']):
        rotate = True
        paname = rsParams.cfg['Fields']['Rotate']
    else:
        rotate = False
        paname = ''

    cadencelist = cadence.CadenceList()
    cadences_file = sdss_path.full('rsCadences', plan=plan,
                                   observatory=observatory)
    print(cadences_file)
    cadencelist.fromfits(filename=cadences_file, unpickle=True)

    allocate_file = sdss_path.full('rsAllocation', plan=plan,
                                   observatory=observatory)
    allocate = robostrategy.allocate.AllocateLST(filename=allocate_file,
                                                 observatory=observatory)

    if(end < 0):
        end = allocate.field_array['fieldid'].max()
    ikeep = np.where((allocate.field_array['fieldid'] >= start) &
                     (allocate.field_array['fieldid'] <= end))[0]

    if coordinate:
        print("Identifying duplicate targets")
        target_covered_file = sdss_path.full('rsTargets', plan=plan,
                                                  observatory=observatory).replace('rsTargets','rsTargetsCovered')
        targets_covered = fitsio.read(target_covered_file)
        in_hex = targets_covered['within_hex']
        duplicated = targets_covered[in_hex > 1]
        temp_dict = {x:False for x in duplicated['rsid']}

        print("beginning multiprocessing section")
        with multiprocessing.Manager() as manager:
            d = manager.dict(temp_dict)
            print('Initiate Pool processing')

            t1 = time.time()
            test = 12 in d.keys()
            t2 = time.time()
            test2 = 12 in temp_dict.keys()
            t3 = time.time()
            print('Time to search shared dict: {}'.format(t2-t1))
            print('Time to search regular dict: {}'.format(t3-t2))

            pdb.set_trace()
            with multiprocessing.Pool() as pool:
                pool.map(assign_field, zip(repeat(d,len(ikeep)),ikeep))
    else:
        with multiprocessing.Pool() as pool:
            pool.map(assign_field,zip(repeat(None, len(ikeep)),ikeep))
